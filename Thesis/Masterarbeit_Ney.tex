%
% FH Technikum Wien
% !TEX encoding = UTF-8 Unicode
%
% Erstellung von Master- und Bachelorarbeiten an der FH Technikum Wien mit Hilfe von LaTeX und der Klasse TWBOOK
%
% Um ein eigenes Dokument zu erstellen, müssen Sie folgendes ergänzen:
% 1) Mit \documentclass[..] einstellen: Master- oder Bachelorarbeit, Studiengang und Sprache
% 2) Mit \newcommand{\FHTWCitationType}.. Zitierstandard festlegen (wird in der Regel vom Studiengang vorgegeben - bitte erfragen)
% 3) Deckblatt, Kurzfassung, etc. ausfüllen
% 4) und die Arbeit schreiben (die verwendeten Literaturquellen in Literatur.bib eintragen)
%
% Getestet mit TeXstudio mit Zeichenkodierung ISO-8859-1 (=ansinew/latin1) und MikTex unter Windows
% Zu beachten ist, dass die Kodierung der Datei mit der Kodierung des paketes inputenc zusammen passt!
% Die Kodierung der Datei twbook.cls MUSS ANSI betragen!
% Bei der Verwendung von UTF8 muss dnicht nur die Kodierung des Dokuments auf UTF8 gestellt sein, sondern auch die des BibTex-Files!
%
% Bugreports und Feedback bitte per E-Mail an latex@technikum-wien.at
%
% Versionen
% *) V0.7: 9.1.2015, RO: Modeline angepasst und verschoben
% *) V0.6: 10.10.2014, RO: Weitere Anpassung an die UK
% *) V0.5: 8.8.2014, WK: Literaturquellen überarbeitet und angepasst
% *) V0.4: 4.8.2014, WK: Initalversion in SVN eingespielt
%
\documentclass[MES,Master,ngerman]{twbook}%\documentclass[Bachelor,BMR,german]{twbook}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{subcaption} 

%
% Bitte in der folgenden Zeile den Zitierstandard festlegen
\newcommand{\FHTWCitationType}{IEEE} % IEEE oder HARVARD möglich - wenn Sie zwischen IEEE und HARVARD wechseln, bitte die temorären Dateien (aux, bbl, ...) löschen
%
\ifthenelse{\equal{\FHTWCitationType}{HARVARD}}{\usepackage{harvard}}{\usepackage{bibgerm}}

% Definition Code-Listings Formatierung:
\usepackage[final]{listings}
\lstset{captionpos=b, numberbychapter=false,caption=\lstname,frame=single, numbers=left, stepnumber=1, numbersep=2pt, xleftmargin=15pt, framexleftmargin=15pt, numberstyle=\tiny, tabsize=3, columns=fixed, basicstyle={\fontfamily{pcr}\selectfont\footnotesize}, keywordstyle=\bfseries, commentstyle={\color[gray]{0.33}\itshape}, stringstyle=\color[gray]{0.25}, breaklines, breakatwhitespace, breakautoindent}
\lstloadlanguages{[ANSI]C, C++, [gnu]make, gnuplot, Matlab}

%Formatieren des Quellcodeverzeichnisses
\makeatletter
% Setzen der Bezeichnungen für das Quellcodeverzeichnis/Abkürzungsverzeichnis in Abhängigkeit von der eingestellten Sprache
\providecommand\listacroname{}
\@ifclasswith{twbook}{english}
{%
    \renewcommand\lstlistingname{Code}
    \renewcommand\lstlistlistingname{List of Code}
    \renewcommand\listacroname{List of Abbreviations}
}{%
    \renewcommand\lstlistingname{Quellcode}
    \renewcommand\lstlistlistingname{Quellcodeverzeichnis}
    \renewcommand\listacroname{Abkürzungsverzeichnis}
}
% Wenn die Option listof=entryprefix gewählt wurde, Definition des Entyprefixes für das Quellcodeverzeichnis. Definition des Macros listoflolentryname analog zu listoflofentryname und listoflotentryname der KOMA-Klasse
\@ifclasswith{scrbook}{listof=entryprefix}
{%
    \newcommand\listoflolentryname\lstlistingname
}{%
}
\makeatother
\newcommand{\listofcode}{\phantomsection\lstlistoflistings}

% Die nachfolgenden Pakete stellen sonst nicht benötigte Features zur Verfügung
\usepackage{blindtext}

%
% Einträge für Deckblatt, Kurzfassung, etc.
%
\title{Der Objekt Orientierte Ansatz in der Entwicklung von Eingebetteten Systemen}
\author{Ney Fränz, BSc}
\studentnumber{1610297013}
%\author{Titel Vorname Name, Titel\and{}Titel Vorname Name, Titel}
%\studentnumber{XXXXXXXXXXXXXXX\and{}XXXXXXXXXXXXXXX}
\supervisor{FH-Prof. Dipl.-Ing. Dr. Martin Horauer}
%\supervisor[Begutachter]{Titel Vorname Name, Titel}
%\supervisor[Begutachterin]{Titel Vorname Name, Titel}
%\secondsupervisor{Titel Vorname Name, Titel}
%\secondsupervisor[Begutachter]{Titel Vorname Name, Titel}
%\secondsupervisor[Begutachterinnen]{Titel Vorname Name, Titel}
\place{Wien}
\kurzfassung{
In der Entwicklung von eingebetteten Systemen hat sich in den letzten Jahren einiges getan. Moderne Programmiersprachen wie C/C++ haben sich in der embedded Entwicklung etabliert und aufwendiges programmieren in Assembler sollte nur noch in wenigen Fällen von Nöten sein. Diese Arbeit beschäftigt sich hauptsächlich mit der Frage, ob der Einsatz einer objektorientierten Programmiersprache auf Plattformen mit nur wenigen kBytes an Flash Speicher sinnvoll ist und welchen Mehrwert diese für die Embedded Entwicklung haben könnte. \newline \newline Hierbei sollen vor allem die gängigsten Konzepte (Klassen, Templates, etc.) der objektorientierten Sprache analysiert werden, um Solide Richtwerte über Performance und Speicherverbrauch geben zu können. Dazu soll der kompilierte Code analysiert und diverse Benchmark Tests durchgeführt werden. Zusätzlich wird der Vergleich mit einer klassischen funktionalen Programmiersprache dargestellt. \newline \newline Als Referenz Programmiersprache wird C/C++ in Verbindung mit der ARM Cortex-M Architektur verwendet, da diese Kombination sehr interessant für stromsparende und kleinere IoT Projekte ist und sich wahrscheinlich in Zukunft durchsetzen wird. Am Anfang wird auch eine State-Of-the-art Analyse über die momentan verfügbaren ARM C++ Compiler durchgeführt um auflisten zu können welche Versionen und Erweiterungen von C++ unterstützt werden.

}
\schlagworte{Objektorientiertes Programmieren, C/C++, Embedded Software, ARM Cortex-M}
\outline{\blindtext}
\keywords{Keyword1, Keyword2, Keyword3, Keyword4}
\acknowledgements{\blindtext}

\begin{document}


%Festlegungen für den HARVARD-Zitierstandard
\ifthenelse{\equal{\FHTWCitationType}{HARVARD}}{
\bibliographystyle{Harvard_FHTW_MES}%Zitierstandard FH Technikum Wien, Studiengang Mechatronik/Robotik, Version 1.2e
\citationstyle{dcu}%Correct citation-style (Harvardand, ";" between citations, "," between author and year)
\citationmode{abbr}%use "et al." with first citation
\iflanguage{ngerman}{
    %Deutsch Neue Rechtschreibung
    \newcommand{\citepic}[1]{(Quelle: \protect\cite{#1})}%Zitat: Bild
    \newcommand{\citefig}[2]{(Quelle: \protect\cite{#1}, S. #2)}%Zitat: Bild aus Dokument
    \newcommand{\citefigm}[2]{(Quelle: modifiziert "ubernommen aus \protect\cite{#1}, S. #2)}%Zitat: modifiziertes Bild aus Dokument
    \newcommand{\citep}{\citeasnoun}%In-Line Zitiat entweder mit \citep{} oder \citeasnoun{}
    \newcommand{\acessedthrough}{Verf{\"u}gbar unter:}%Für URL-Angabe
    \newcommand{\acessedthroughp}{Verf{\"u}gbar bei:}%Für URL-Angabe (Geschützte Datenbank, Zugriff durch FH)
    \newcommand{\acessedat}{Zugang am}%Für URL-Datum-Angabe
    \newcommand{\singlepage}{S.}%Für Seitenangabe (einzelne Seite)
    \newcommand{\multiplepages}{S.}%Für Seitenangabe (mehrere Seiten)
    \newcommand{\chapternr}{K.}%Für Kapitelangabe
    \renewcommand{\harvardand}{\&}%Harvardand in Zitaten
    \newcommand{\abstractonly}{ausschließlich Abstract}
    \newcommand{\edition}{. Auflage}%Angabe der Auflage
}{
\iflanguage{german}{
    %Deutsch
    \newcommand{\citepic}[1]{(Quelle: \protect\cite{#1})}%Zitat: Bild
    \newcommand{\citefig}[2]{(Quelle: \protect\cite{#1}, S. #2)}%Zitat: Bild aus Dokument
    \newcommand{\citefigm}[2]{(Quelle: modifiziert "ubernommen aus \protect\cite{#1}, S. #2)}%Zitat: modifiziertes Bild aus Dokument
    \newcommand{\citep}{\citeasnoun}%In-Line Zitiat entweder mit \citep{} oder \citeasnoun{}
    \newcommand{\acessedthrough}{Verf{\"u}gbar unter:}%Für URL-Angabe
    \newcommand{\acessedthroughp}{Verf{\"u}gbar bei:}%Für URL-Angabe (Geschützte Datenbank, Zugriff durch FH)
    \newcommand{\acessedat}{Zugang am}%Für URL-Datum-Angabe
    \newcommand{\singlepage}{S.}%Für Seitenangabe (einzelne Seite)
    \newcommand{\multiplepages}{S.}%Für Seitenangabe (mehrere Seiten)
    \newcommand{\chapternr}{K.}%Für Kapitelangabe
    \renewcommand{\harvardand}{\&}%Harvardand in Zitaten
    \newcommand{\abstractonly}{ausschließlich Abstract}
    \newcommand{\edition}{. Auflage}%Angabe der Auflage
}{
    %Englisch
    \newcommand{\citepic}[1]{(Source: \protect\cite{#1})}%Zitat: Bild
    \newcommand{\citefig}[2]{(Source: \protect\cite{#1}, p. #2)}%Zitat: Bild aus Dokument
    \newcommand{\citefigm}[2]{(Source: taken with modification from \protect\cite{#1}, p. #2)}%Zitat: modifiziertes Bild aus Dokument
    \newcommand{\citep}{\citeasnoun}%In-Line Zitiat entweder mit \citep{} oder \citeasnoun{}
    \newcommand{\acessedthrough}{Available at:}%Für URL-Angabe
    \newcommand{\acessedthroughp}{Available through:}%Für URL-Angabe (Geschützte Datenbank, Zugriff durch FH)
    \newcommand{\acessedat}{Accessed}%Für URL-Datum-Angabe
    \newcommand{\singlepage}{p.}%Für Seitenangabe (einzelne Seite)
    \newcommand{\multiplepages}{pp.}%Für Seitenangabe (mehrere Seiten)
    \newcommand{\chapternr}{Ch.}%Für Kapitelangabe
    \renewcommand{\harvardand}{\&}%Harvardand in Zitaten
    \newcommand{\abstractonly}{Abstract only}
    \newcommand{\edition}{~edition}%Edition -> note, that you have to write "edition = {2nd},"!
}}}

\maketitle


%
% .. und hier beginnt die eigentliche Arbeit. Viel Erfolg beim Verfassen!
%
\chapter{State-of-Art Analyse}
\section{Mikrocontroller Hardware Analyse}
\subsection{Stromverbrauch und Effizienz}
\subsection{MCU Peripherie}
\subsection{Sicherheits- Features}
\section{Work-Flow und Tools in der embedded Entwicklung}
\subsection{Entwicklungs- Umgebungen}
\subsection{Test und Qualitäts- Management}
\subsection{Code Generatoren}
\subsection{Low-Level Hardware Bibliotheken}
\section{Programmiersprachen für die embedded Entwicklung}
\subsection{Kompilierte Programmiersprachen}
\subsection{Interpretierte Programmiersprachen}
\section{Verfügbare C/C++ Compiler für die ARM Architektur}
\subsection{GNU Arm Embedded Toolchain}
\subsection{IAR Embedded Workbench}
\subsection{ARM Compiler}


\chapter{Embedded C++}
\subsection{Überblick}
In diesem Kapitel werden verschiedene Konzepte von C++ näher analysiert um klare Aussagen über Speicherverbrauch und Performance liefern zu können. Es soll zugleich als eine Art Guideline für Embedded Programmierer dienen um C++ effizient einsetzen zu können. \newline 

Die GNU ARM Embbedded Toolchain wird für diese Tests verwendet da Sie neben Compiler, Linker und Co. auch noch viele nützliche Tools zur Analyse mitliefert. Verschieden Tools die in den nachfolgenden Kapiteln zum Einsatz kommen werden in Tabelle \ref{tbl:analystools} aufgelistet.

\begin{table}[!htb]
	\centering
	\begin{tabular}{| l | c | r |}
		\hline
		\textbf{Tool}  & \textbf{Beschreibung} \\ \hline
		arm-none-eabi-g++           & C++ Compiler (Präprozessor , Kompiler, Linker) \\ \hline
		arm-none-eabi-gcc       	& C	  Compiler (Präprozessor , Kompiler, Linker) \\ \hline
		arm-mone-eabi-nm        	& Listet Symbole aus Objekt Dateien \\ \hline
		arm-none-eabi-objdump		& Zur erweiterten Analyse von Objekt Dateien \\ \hline
		arm-none-eabi-size			& Zeigt Größe der verschieden Link Segmente (Text, Data, BSS) \\ \hline
	\end{tabular}
	
	\caption{Analyse Tools}
	\label{tbl:analystools}
	% Verweis im Text mittels \ref{tbl:beispieltabelle}
	
\end{table}

\subsection{C++ Konzepte}
\subsection{Eingabe- und Ausgabestreams}

\newpage
\subsection{'auto'-Typ}
\newpage
\subsection{Funktionen Überladen}
C++ bietet ein Mechanismus indem man mehrere Funktionen mit dem gleichen Namen deklarieren kann, diese sich jedoch in ihrer Signatur unterscheiden müssen. Somit kann man bestehende Funktionen überladen, indem man die Datentypen oder Anzahl der Parameter verändert. Der Compiler sucht sich dann die Funktion mit der passenden Signatur heraus. 
\subsubsection{Beispiel} \label{beispiel:1}
Im folgendem Beispiel braucht man eine Funktion die jeweils 2 \textbf{int} und \textbf{double} Werte addieren kann. Im klassischen C müsste man 2 Funktionen deklarieren die sich jeweils in ihrem Namen unterscheiden, wohingegen man in C++ den gleichen Funktions- Namen erneut verwenden darf.
\begin{figure}[!htb]
	\begin{subfigure}[b]{0.5\textwidth}
		\lstset{language=C++,caption={C++ Beispiel}}
		\lstinputlisting{../Code_Samples/Funkionen_Uberladen/C++/main.cpp}
		\label{fig:1}
	\end{subfigure}
	%
	\begin{subfigure}[b]{0.5\textwidth}
		\lstset{language=C,caption={C Beispiel}}
		\lstinputlisting{../Code_Samples/Funkionen_Uberladen/C/main.c}
		\label{fig:2}
	\end{subfigure}
\end{figure}

\subsubsection{Analyse}
Beide Compiler generieren jeweils eine Funktion für \textbf{int} (0x30 byte) und eine für \textbf{double} (0x4c byte). Beim C++ Compiler kann man erkennen das dieser automatisch 2 Funktionen mit dem Index 'ii' und 'dd' erstellt. Somit kann man sagen das Funktions- Überladungen keinen Speicher Overhead erzeugen. Zudem erspart man sich lange Funktions- Namen und vermeidet dass man im Code irrtümlicherweise die falsche Funktion aufruft.
\begin{figure}[!htb]
	\begin{subfigure}[b]{0.5\textwidth}
		\begin{lstlisting}[gobble=6, title={Compiler Output C++}, language=bash, numbers=none]
		$ arm-none-eabi-nm.exe a.out --print-size
		...
		00008244 00000030 T _Z8addierenii
		00008274 0000004c T _Z8addierendd
		...
		\end{lstlisting}
	\end{subfigure}
	%
	\begin{subfigure}[b]{0.5\textwidth}
		\begin{lstlisting}[gobble=6, title={Compiler Output C}, language=bash, numbers=none]
		$ arm-none-eabi-nm.exe a.out --print-size
		...
		00008244 00000030 T add_i
		00008274 0000004c T add_d
		...
		\end{lstlisting}
	\end{subfigure}
\end{figure}

\subsubsection{Fazit}
Funktions- Überladungen erzeugen keinen Speicher Overhead und sind zu empfehlen wenn sich der Funktions- Block erheblich in verschiedenen Implementationen unterscheidet. Ändern sich nur die Datentypen wie es in diesem Beispiel der Fall ist sind \textit{Funktions- Templates} eher zu empfehlen. Ändert sich nur die Anzahl der Parameter kann man oftmals mit \textit{Default Arguments} wie es sie in C++ gibt schöneren Code erzeugen.

\newpage
\subsection{Funktions- Templates}
Oftmals muss man eine und dieselbe Funktion für verschiedene Datentypen implementieren. In C++ kann man dieses Problem mit Templates sehr elegant lösen. Templates stellen eine Art Schablone dar mit denen man Funktionen unabhängig von einem bestimmten Datentypen implementieren kann. Dies ist vor allem bei Manipulationen von Listen oder Arrays sehr interessant.
\subsubsection{Beispiel}
Das nachfolgende Beispiel zeigt wie man in C++ eine Funktion die 2 Werte addieren soll unabhängig von dessen Datentypen implementieren kann. Erkennbar ist auch dass die C++ Variante wesentlich kürzer und somit auch übersichtlicher als die Version in C wirkt.
\begin{figure}[!htb]
	\begin{subfigure}[b]{0.5\textwidth}
		\lstset{language=C++,caption={C++ Beispiel}, keepspaces=true}
		\lstinputlisting{../Code_Samples/Funkions_Templates/C++/main.cpp}
		\label{fig:3}
	\end{subfigure}
	%
	\begin{subfigure}[b]{0.5\textwidth}
		\lstset{language=C,caption={C Beispiel}}
		\lstinputlisting{../Code_Samples/Funkions_Templates/C/main.c}
		\label{fig:4}
	\end{subfigure}
\end{figure}
\subsubsection{Analyse}
Als auch schon vorigen Beispiel \ref{beispiel:1} generiert der C und C++ Compiler jeweils eine Funktion für die \textbf{int} und \textbf{double} Addition. Somit erzeugen Funktion- Templates bei richtiger Verwendung auch keinen Speicher Overhead. Erkennbar ist das der C++ Compiler die 2 Funktionen jeweils als 'WEAK' markiert. Somit wird die Template Funktion nicht als fixes Objekt deklariert und könnte von einer anderen implemetierung in einer andern Datei überschrieben werden. Um dies zu verhindern sollte sich Templates definitionen immer in einer Headerdatei befinden und wenn nötig eingebunden werden.
\begin{figure}[!htb]
	\begin{subfigure}[b]{0.5\textwidth}
		\begin{lstlisting}[gobble=6, title={Compiler Output C++}, language=bash, numbers=none]
		$ arm-none-eabi-nm.exe a.out --print-size
		...
		000082c8 00000030 W _Z3addIiET_S0_S0_
		000082f8 0000004c W _Z3addIdET_S0_S0_
		...
		\end{lstlisting}
	\end{subfigure}
	%
	\begin{subfigure}[b]{0.5\textwidth}
		\begin{lstlisting}[gobble=6, title={Compiler Output C}, language=bash, numbers=none]
		$ arm-none-eabi-nm.exe a.out --print-size
		...
		00008244 00000030 T add_i
		00008274 0000004c T add_d
		...
		\end{lstlisting}
	\end{subfigure}
\end{figure}

\subsubsection{Fazit}
Funktions- Templates erhöhen die Lesbarkeit des Quellcodes und bewirken das man Fehler nur in einer Funktion beheben muss und somit eine sehr häufige Fehlerquelle ausschließen. 

\newpage

\subsection{Arrays}
In C++ gibt es mehrere Möglichkeiten Daten in Arrays zusammenzufassen. C- Array, sdt::vector und std::array sind die 3 bekanntesten Modelle um Daten zu speichern und werden in diesem Kapitel näher unter die Lupe genommen. Als embedded Programmierer sollte man genau wissen welche Methode für den jeweiligen Anwendungsfall die beste Wahl ist.

\subsubsection{C- Array / std::arry}
Das klassische C- Array ist nach wie vor weit verbreitet und kann auch in C++ verwendet werden. Jedoch sollte man in neuen Programmen darauf verzichten da es in der Standard C++ Bibliothek verschiedene Container Klassen gibt die übersichtlicher aufgebaut sind und somit gängige Fehler im Vorhinein eliminieren. Die sdt::array Containerklasse is das Pendant zum C- Array, bietet jedoch einige Vorteile was Elementzugriff oder Informationen über die Kapazität das Arrays betrifft. Näher zu erwähnen ist die Methode \textbf{at} mit der man Zugriff auf einzelne Elemente des Arrays bekommt, jedoch gegenüber \textbf{[ ]} eine Grenzeinüberprüfung während der Laufzeit stattfindet. Dies kann sehr nützlich sein da der Zugriff auf nicht existierende Elemente einer der häufigsten Fehler bei C- Arrays darstellt. \newline \newline Ein zusätzlicher Vorteil bieten die Standard C++ Container Klassen da diese Iteratoren zu Verfügung stellen womit man verschiedene Algorithmen der Standard Bibliothek verwenden kann. Somit kann man auf vorhandenen und getesteten Code zurückgreifen wenn es ums sortieren oder das manipulieren eines Arrays geht.


\begin{figure}[!htb]
	\begin{subfigure}[b]{0.5\textwidth}
		\lstset{language=C++,caption={C- Array}}
		\lstinputlisting{../Code_Samples/std_vector_vs_std_array_vs_c_array/C_Array/c_array.cpp}
		\label{fig:5}
	\end{subfigure}
	%
	\begin{subfigure}[b]{0.5\textwidth}
		\lstset{language=C++,caption={std::array}}
		\lstinputlisting{../Code_Samples/std_vector_vs_std_array_vs_c_array/std_array/stdArray.cpp}
		\label{fig:6}
	\end{subfigure}
\end{figure}

\subsubsection{std::vector}



\subsection{Pointer vs Referenzen}
\subsection{Namespaces}
\subsection{Dynamische Speicher Verwaltung}
\subsection{Klassen}
\subsubsection{Konstruktoren}
\subsubsection{Destruktoren}



%
% Hier beginnen die Verzeichnisse.
%
\clearpage
\ifthenelse{\equal{\FHTWCitationType}{HARVARD}}{}{\bibliographystyle{gerabbrv}}
\bibliography{Literatur}
\clearpage

% Das Abbildungsverzeichnis
\listoffigures
\clearpage

% Das Tabellenverzeichnis
\listoftables
\clearpage

% Das Quellcodeverzeichnis
\listofcode
\clearpage

\phantomsection
\addcontentsline{toc}{chapter}{\listacroname}
\chapter*{\listacroname}
\begin{acronym}[XXXXX]
    \acro{ABC}[ABC]{Alphabet}
    \acro{WWW}[WWW]{world wide web}
    \acro{ROFL}[ROFL]{Rolling on floor laughing}
\end{acronym}

%
% Hier beginnt der Anhang.
%
\clearpage
\appendix
\chapter{Anhang A}
\clearpage
\chapter{Anhang B}
\end{document}