%
% FH Technikum Wien
% !TEX encoding = UTF-8 Unicode
%
% Erstellung von Master- und Bachelorarbeiten an der FH Technikum Wien mit Hilfe von LaTeX und der Klasse TWBOOK
%
% Um ein eigenes Dokument zu erstellen, müssen Sie folgendes ergänzen:
% 1) Mit \documentclass[..] einstellen: Master- oder Bachelorarbeit, Studiengang und Sprache
% 2) Mit \newcommand{\FHTWCitationType}.. Zitierstandard festlegen (wird in der Regel vom Studiengang vorgegeben - bitte erfragen)
% 3) Deckblatt, Kurzfassung, etc. ausfüllen
% 4) und die Arbeit schreiben (die verwendeten Literaturquellen in Literatur.bib eintragen)
%
% Getestet mit TeXstudio mit Zeichenkodierung ISO-8859-1 (=ansinew/latin1) und MikTex unter Windows
% Zu beachten ist, dass die Kodierung der Datei mit der Kodierung des paketes inputenc zusammen passt!
% Die Kodierung der Datei twbook.cls MUSS ANSI betragen!
% Bei der Verwendung von UTF8 muss dnicht nur die Kodierung des Dokuments auf UTF8 gestellt sein, sondern auch die des BibTex-Files!
%
% Bugreports und Feedback bitte per E-Mail an latex@technikum-wien.at
%
% Versionen
% *) V0.7: 9.1.2015, RO: Modeline angepasst und verschoben
% *) V0.6: 10.10.2014, RO: Weitere Anpassung an die UK
% *) V0.5: 8.8.2014, WK: Literaturquellen überarbeitet und angepasst
% *) V0.4: 4.8.2014, WK: Initalversion in SVN eingespielt
%
\documentclass[MES,Master,ngerman]{twbook}%\documentclass[Bachelor,BMR,german]{twbook}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{subcaption} 

%
% Bitte in der folgenden Zeile den Zitierstandard festlegen
\newcommand{\FHTWCitationType}{IEEE} % IEEE oder HARVARD möglich - wenn Sie zwischen IEEE und HARVARD wechseln, bitte die temorären Dateien (aux, bbl, ...) löschen
%
\ifthenelse{\equal{\FHTWCitationType}{HARVARD}}{\usepackage{harvard}}{\usepackage{bibgerm}}

% Definition Code-Listings Formatierung:
\usepackage[final]{listings}
\lstset{captionpos=b, numberbychapter=false,caption=\lstname,frame=single, numbers=left, stepnumber=1, numbersep=2pt, xleftmargin=15pt, framexleftmargin=15pt, numberstyle=\tiny, tabsize=3, columns=fixed, basicstyle={\fontfamily{pcr}\selectfont\footnotesize}, keywordstyle=\bfseries, commentstyle={\color[gray]{0.33}\itshape}, stringstyle=\color[gray]{0.25}, breaklines, breakatwhitespace, breakautoindent}
\lstloadlanguages{[ANSI]C, C++, [gnu]make, gnuplot, Matlab}

%Formatieren des Quellcodeverzeichnisses
\makeatletter
% Setzen der Bezeichnungen für das Quellcodeverzeichnis/Abkürzungsverzeichnis in Abhängigkeit von der eingestellten Sprache
\providecommand\listacroname{}
\@ifclasswith{twbook}{english}
{%
    \renewcommand\lstlistingname{Code}
    \renewcommand\lstlistlistingname{List of Code}
    \renewcommand\listacroname{List of Abbreviations}
}{%
    \renewcommand\lstlistingname{Quellcode}
    \renewcommand\lstlistlistingname{Quellcodeverzeichnis}
    \renewcommand\listacroname{Abkürzungsverzeichnis}
}
% Wenn die Option listof=entryprefix gewählt wurde, Definition des Entyprefixes für das Quellcodeverzeichnis. Definition des Macros listoflolentryname analog zu listoflofentryname und listoflotentryname der KOMA-Klasse
\@ifclasswith{scrbook}{listof=entryprefix}
{%
    \newcommand\listoflolentryname\lstlistingname
}{%
}
\makeatother
\newcommand{\listofcode}{\phantomsection\lstlistoflistings}

% Die nachfolgenden Pakete stellen sonst nicht benötigte Features zur Verfügung
\usepackage{blindtext}

%
% Einträge für Deckblatt, Kurzfassung, etc.
%
\title{Der Objekt Orientierte Ansatz in der Entwicklung von Eingebetteten Systemen}
\author{Ney Fränz, BSc}
\studentnumber{1610297013}
%\author{Titel Vorname Name, Titel\and{}Titel Vorname Name, Titel}
%\studentnumber{XXXXXXXXXXXXXXX\and{}XXXXXXXXXXXXXXX}
\supervisor{FH-Prof. Dipl.-Ing. Dr. Martin Horauer}
%\supervisor[Begutachter]{Titel Vorname Name, Titel}
%\supervisor[Begutachterin]{Titel Vorname Name, Titel}
%\secondsupervisor{Titel Vorname Name, Titel}
%\secondsupervisor[Begutachter]{Titel Vorname Name, Titel}
%\secondsupervisor[Begutachterinnen]{Titel Vorname Name, Titel}
\place{Wien}
\kurzfassung{
In der Entwicklung von eingebetteten Systemen hat sich in den letzten Jahren einiges getan. Moderne Programmiersprachen wie C/C++ haben sich in der embedded Entwicklung etabliert und aufwendiges programmieren in Assembler sollte nur noch in wenigen Fällen von Nöten sein. Diese Arbeit beschäftigt sich hauptsächlich mit der Frage, ob der Einsatz einer objektorientierten Programmiersprache auf Plattformen mit nur wenigen kBytes an Flash Speicher sinnvoll ist und welchen Mehrwert diese für die Embedded Entwicklung haben könnte. \newline \newline Hierbei sollen vor allem die gängigsten Konzepte (Klassen, Templates, etc.) der objektorientierten Sprache analysiert werden, um Solide Richtwerte über Performance und Speicherverbrauch geben zu können. Dazu soll der kompilierte Code analysiert und diverse Benchmark Tests durchgeführt werden. Zusätzlich wird der Vergleich mit einer klassischen funktionalen Programmiersprache dargestellt. \newline \newline Als Referenz Programmiersprache wird C/C++ in Verbindung mit der ARM Cortex-M Architektur verwendet, da diese Kombination sehr interessant für stromsparende und kleinere IoT Projekte ist und sich wahrscheinlich in Zukunft durchsetzen wird. Am Anfang wird auch eine State-Of-the-art Analyse über die momentan verfügbaren ARM C++ Compiler durchgeführt um auflisten zu können welche Versionen und Erweiterungen von C++ unterstützt werden.

}
\schlagworte{Objektorientiertes Programmieren, C/C++, Embedded Software, ARM Cortex-M}
\outline{\blindtext}
\keywords{Keyword1, Keyword2, Keyword3, Keyword4}
\acknowledgements{\blindtext}

\begin{document}


%Festlegungen für den HARVARD-Zitierstandard
\ifthenelse{\equal{\FHTWCitationType}{HARVARD}}{
\bibliographystyle{Harvard_FHTW_MES}%Zitierstandard FH Technikum Wien, Studiengang Mechatronik/Robotik, Version 1.2e
\citationstyle{dcu}%Correct citation-style (Harvardand, ";" between citations, "," between author and year)
\citationmode{abbr}%use "et al." with first citation
\iflanguage{ngerman}{
    %Deutsch Neue Rechtschreibung
    \newcommand{\citepic}[1]{(Quelle: \protect\cite{#1})}%Zitat: Bild
    \newcommand{\citefig}[2]{(Quelle: \protect\cite{#1}, S. #2)}%Zitat: Bild aus Dokument
    \newcommand{\citefigm}[2]{(Quelle: modifiziert "ubernommen aus \protect\cite{#1}, S. #2)}%Zitat: modifiziertes Bild aus Dokument
    \newcommand{\citep}{\citeasnoun}%In-Line Zitiat entweder mit \citep{} oder \citeasnoun{}
    \newcommand{\acessedthrough}{Verf{\"u}gbar unter:}%Für URL-Angabe
    \newcommand{\acessedthroughp}{Verf{\"u}gbar bei:}%Für URL-Angabe (Geschützte Datenbank, Zugriff durch FH)
    \newcommand{\acessedat}{Zugang am}%Für URL-Datum-Angabe
    \newcommand{\singlepage}{S.}%Für Seitenangabe (einzelne Seite)
    \newcommand{\multiplepages}{S.}%Für Seitenangabe (mehrere Seiten)
    \newcommand{\chapternr}{K.}%Für Kapitelangabe
    \renewcommand{\harvardand}{\&}%Harvardand in Zitaten
    \newcommand{\abstractonly}{ausschließlich Abstract}
    \newcommand{\edition}{. Auflage}%Angabe der Auflage
}{
\iflanguage{german}{
    %Deutsch
    \newcommand{\citepic}[1]{(Quelle: \protect\cite{#1})}%Zitat: Bild
    \newcommand{\citefig}[2]{(Quelle: \protect\cite{#1}, S. #2)}%Zitat: Bild aus Dokument
    \newcommand{\citefigm}[2]{(Quelle: modifiziert "ubernommen aus \protect\cite{#1}, S. #2)}%Zitat: modifiziertes Bild aus Dokument
    \newcommand{\citep}{\citeasnoun}%In-Line Zitiat entweder mit \citep{} oder \citeasnoun{}
    \newcommand{\acessedthrough}{Verf{\"u}gbar unter:}%Für URL-Angabe
    \newcommand{\acessedthroughp}{Verf{\"u}gbar bei:}%Für URL-Angabe (Geschützte Datenbank, Zugriff durch FH)
    \newcommand{\acessedat}{Zugang am}%Für URL-Datum-Angabe
    \newcommand{\singlepage}{S.}%Für Seitenangabe (einzelne Seite)
    \newcommand{\multiplepages}{S.}%Für Seitenangabe (mehrere Seiten)
    \newcommand{\chapternr}{K.}%Für Kapitelangabe
    \renewcommand{\harvardand}{\&}%Harvardand in Zitaten
    \newcommand{\abstractonly}{ausschließlich Abstract}
    \newcommand{\edition}{. Auflage}%Angabe der Auflage
}{
    %Englisch
    \newcommand{\citepic}[1]{(Source: \protect\cite{#1})}%Zitat: Bild
    \newcommand{\citefig}[2]{(Source: \protect\cite{#1}, p. #2)}%Zitat: Bild aus Dokument
    \newcommand{\citefigm}[2]{(Source: taken with modification from \protect\cite{#1}, p. #2)}%Zitat: modifiziertes Bild aus Dokument
    \newcommand{\citep}{\citeasnoun}%In-Line Zitiat entweder mit \citep{} oder \citeasnoun{}
    \newcommand{\acessedthrough}{Available at:}%Für URL-Angabe
    \newcommand{\acessedthroughp}{Available through:}%Für URL-Angabe (Geschützte Datenbank, Zugriff durch FH)
    \newcommand{\acessedat}{Accessed}%Für URL-Datum-Angabe
    \newcommand{\singlepage}{p.}%Für Seitenangabe (einzelne Seite)
    \newcommand{\multiplepages}{pp.}%Für Seitenangabe (mehrere Seiten)
    \newcommand{\chapternr}{Ch.}%Für Kapitelangabe
    \renewcommand{\harvardand}{\&}%Harvardand in Zitaten
    \newcommand{\abstractonly}{Abstract only}
    \newcommand{\edition}{~edition}%Edition -> note, that you have to write "edition = {2nd},"!
}}}

\maketitle


%
% .. und hier beginnt die eigentliche Arbeit. Viel Erfolg beim Verfassen!
%
\chapter{State-of-Art Analyse}
\section{Mikrocontroller Hardware Analyse}
\subsection{Stromverbrauch und Effizienz}
\subsection{MCU Peripherie}
\subsection{Sicherheits- Features}
\section{Work-Flow und Tools in der embedded Entwicklung}
\subsection{Entwicklungs- Umgebungen}
\subsection{Test und Qualitäts- Management}
\subsection{Code Generatoren}
\subsection{Low-Level Hardware Bibliotheken}
\section{Programmiersprachen für die embedded Entwicklung}
\subsection{Kompilierte Programmiersprachen}
\subsection{Interpretierte Programmiersprachen}
\section{Verfügbare C/C++ Compiler für die ARM Architektur}
\subsection{GNU Arm Embedded Toolchain}
\subsection{IAR Embedded Workbench}
\subsection{ARM Compiler}


\chapter{Embedded C++}
\subsection{Überblick}
In diesem Kapitel werden verschiedene Konzepte von C++ näher analysiert um klare Aussagen über Speicherverbrauch und Performance liefern zu können. Es soll zugleich als eine Art Guideline für Embedded Programmierer dienen um C++ effizient einsetzen zu können. \newline 

Die GNU ARM Embbedded Toolchain wird für diese Tests verwendet da Sie neben Compiler, Linker und Co. auch noch viele nützliche Tools zur Analyse mitliefert. Verschieden Tools die in den nachfolgenden Kapiteln zum Einsatz kommen werden in Tabelle \ref{tbl:analystools} aufgelistet.

\begin{table}[!htb]
	\centering
	\begin{tabular}{| l | c | r |}
		\hline
		\textbf{Tool}  & \textbf{Beschreibung} \\ \hline
		arm-none-eabi-g++           & C++ Compiler (Präprozessor , Kompiler, Linker) \\ \hline
		arm-none-eabi-gcc       	& C	  Compiler (Präprozessor , Kompiler, Linker) \\ \hline
		arm-mone-eabi-nm        	& Listet Symbole aus Objekt Dateien \\ \hline
		arm-none-eabi-objdump		& Zur erweiterten Analyse von Objekt Dateien \\ \hline
		arm-none-eabi-size			& Zeigt Größe der verschieden Link Segmente (Text, Data, BSS) \\ \hline
	\end{tabular}
	
	\caption{Analyse Tools}
	\label{tbl:analystools}
	% Verweis im Text mittels \ref{tbl:beispieltabelle}
	
\end{table}


\newpage
\subsection{Funktionen Überladen}
C++ bietet ein Mechanismus indem man mehrere Funktionen mit dem gleichen Namen deklarieren kann, diese sich jedoch in ihrer Signatur unterscheiden müssen. Somit kann man bestehende Funktionen überladen, indem man die Datentypen oder Anzahl der Parameter verändert. Der Compiler sucht sich dann die Funktion mit der passenden Signatur heraus. 
\subsubsection{Beispiel} \label{beispiel:1}
Im folgendem Beispiel braucht man eine Funktion die jeweils 2 \textit{int} und \textit{double} Werte addieren kann. Im klassischen C müsste man 2 Funktionen deklarieren die sich jeweils in ihrem Namen unterscheiden, wohingegen man in C++ den gleichen Funktionsnamen erneut verwenden darf.
\begin{figure}[!htb]
	\begin{subfigure}[b]{0.5\textwidth}
		\lstset{language=C++,caption={C++ Beispiel}}
		\lstinputlisting{../Code_Samples/Funkionen_Uberladen/C++/main.cpp}
		\label{fig:1}
	\end{subfigure}
	%
	\begin{subfigure}[b]{0.5\textwidth}
		\lstset{language=C,caption={C Beispiel}}
		\lstinputlisting{../Code_Samples/Funkionen_Uberladen/C/main.c}
		\label{fig:2}
	\end{subfigure}
\end{figure}

\subsubsection{Analyse}
Beide Compiler generieren jeweils eine Funktion für \textit{int} (48 byte) und eine für \textit{double} (76 byte). Beim C++ Compiler kann man erkennen das dieser automatisch 2 verschiedene Funktionen mit dem Index 'ii' und 'dd' erstellt. Somit kann man sagen das Funktions- Überladungen keinen Speicher Overhead erzeugen. Zusätzlich kann man lange Funktionsnamen vermeiden und die Wahrscheinlichkeit das man irrtümlicherweise die falsche Funktion verwendet sinkt erheblich.
\begin{figure}[!htb]
	\begin{subfigure}[b]{0.5\textwidth}
		\begin{lstlisting}[gobble=6, title={Analyse C++}, language=bash, numbers=none]
		$ arm-none-eabi-g++ -c -O0 main.cpp
		$ arm-none-eabi-nm main.o --print-size
		...
		00000030 0000004c t _ZL3adddd
		00000000 00000030 t _ZL3addii
		...
		\end{lstlisting}
	\end{subfigure}
	%
	\begin{subfigure}[b]{0.5\textwidth}
		\begin{lstlisting}[gobble=6, title={Analyse C}, language=bash, numbers=none]
		$ arm-none-eabi-gcc -c -O0 main.c
		$ arm-none-eabi-nm main.o --print-size
		...
		00000030 0000004c t add_d
		00000000 00000030 t add_i
		...
		\end{lstlisting}
	\end{subfigure}
\end{figure}

\subsubsection{Fazit}
Funktions- Überladungen erzeugen keinen Speicher Overhead und sind zu empfehlen wenn sich der Funktions- Block erheblich in verschiedenen Implementationen unterscheidet. Ändern sich nur die Datentypen wie es in diesem Beispiel der Fall ist sind \textit{Funktions- Templates} eher zu empfehlen. Ändert sich nur die Anzahl der Parameter kann man oftmals mit \textit{Standardparametern} (Default Arguments) wie es sie in C++ gibt schöneren Code erzeugen.

\newpage
\subsection{Standardparameter}
Bei der Initialisierung von Hardware Modulen sind oft Standardparameter sinnvoll. Bei einer Seriellen Schnittelle ist die Konfiguration \textit{9600 8N1} für viele Anwendungen schon ausreichend. In C++ kann man Funktionsparameter mit festen Standardwerten versehen welche geltend sind sollte beim Funktionsaufruf das Argument fehlen. Im klassischen C gibt es mehrere Möglichkeiten so ein Verhalten nach zu implementieren, jedoch ist dies ohne zusätzlichen Quellcode meist nicht möglich.

\subsubsection{Beispiel}          
Das folgende Beispiel zeigt wie man die Initialisierungsfunktion einer Seriellen Schnittstelle mit Standardwerten versehen kann. Sofort erkennbar ist das die gleiche Implementierung in C wesentlich unübersichtlicher wirkt. In der main Funktion werden die verschieden Möglichkeiten dargestellt wie man die Funktion aufrufen könnte.
\begin{figure}[!htb]
	\begin{subfigure}[b]{0.5\textwidth}
		\lstset{language=C++,caption={C++ Beispiel}}
		\lstinputlisting{../Code_Samples/Standardparameter/C++/main.cpp}
		\label{fig:3}
	\end{subfigure}
	%
	\begin{subfigure}[b]{0.5\textwidth}
		\lstset{language=C,caption={C Beispiel}}
		\lstinputlisting{../Code_Samples/Standardparameter/C/main.c}
		\label{fig:4}
	\end{subfigure}
\end{figure}

\subsubsection{Analyse}
Der C++ Compiler ersetzt die nicht angegeben Parametern während der Übersetzungszeit durch die Default-Parameter womit die main Funktion bei beiden Varianten gleich viel ROM Speicher (176 byte) benötigt. Jedoch alloziert die uart\_init Funktion in der C Version mehr Speicher da hier zur Laufzeit die Standardparameter gegebenenfalls gesetzt werden müssen.

\begin{figure}[!htb]
	\begin{subfigure}[b]{0.5\textwidth}
		\begin{lstlisting}[gobble=6, title={Analyse C++}, language=bash, numbers=none]
		$ arm-none-eabi-g++ -c -Os main.cpp
		$ arm-none-eabi-nm a.out --print-size
		...
		00000000 00000010 t _ZL9uart_initiiii
		00000000 000000b0 T main
		00000000 00000004 B ret
		...
		\end{lstlisting}
	\end{subfigure}
	%
	\begin{subfigure}[b]{0.5\textwidth}
		\begin{lstlisting}[gobble=6, title={Analyse C}, language=bash, numbers=none]
		$ arm-none-eabi-gcc -c -Os main.c
		$ arm-none-eabi-nm a.out --print-size
		...
		00000000 0000002c t uart_init
		00000000 000000b0 T main
		00000000 00000004 B ret
		...
		\end{lstlisting}
	\end{subfigure}
\end{figure}
Bei Verwendung von C++ Standardparametern sollte man darauf achten dass man die Parameter, wo die Wahrscheinlichkeit einer Änderung am Höchsten ist ganz links in der Funktionsparameter liste packt. Bei der Seriellen Schnittelle wäre das die Baudrate da sich die restlichen Parameter nicht so häufig ändern.  

\subsubsection{Fazit}
Standardparameter sind sehr nützlich wenn es sich um Konfigurations- Funktionen handelt da man diese übersichtlicher gestalten kann. Auch Funktions- Aufrufe mit langen Parameter Listen kann man vermeiden wenn einem die Standard Werte genügen. 

\newpage

\subsection{Funktions- Templates}
Oftmals muss man eine und dieselbe Funktion für verschiedene Datentypen implementieren. In C++ kann man dieses Problem mit Templates sehr elegant lösen. Templates stellen eine Art Schablone dar mit denen man Funktionen unabhängig von einem bestimmten Datentypen implementieren kann. Dies ist vor allem bei Manipulationen von Listen oder Arrays interessant da man den Algorithmus nicht für jeden Datentyp erneut implementieren muss.

\subsubsection{Beispiel}
Das nachfolgende Beispiel zeigt wie man in C++ eine Funktion die 2 Werte addieren soll unabhängig von dessen Datentypen implementieren kann. Erkennbar ist auch dass die C++ Variante wesentlich kürzer und somit auch übersichtlicher als die Version in C wirkt.
\begin{figure}[!htb]
	\begin{subfigure}[b]{0.5\textwidth}
		\lstset{language=C++,caption={C++ Beispiel}}
		\lstinputlisting{../Code_Samples/Funkions_Templates/C++/main.cpp}
		\label{fig:5}
	\end{subfigure}
	%
	\begin{subfigure}[b]{0.5\textwidth}
		\lstset{language=C,caption={C Beispiel}}
		\lstinputlisting{../Code_Samples/Funkions_Templates/C/main.c}
		\label{fig:6}
	\end{subfigure}
\end{figure}
\subsubsection{Analyse}

Beide Versionen wurden mit der Compiler Optimierung \textbf{-O0} kompiliert. Analysiert man beide Objekt Dateien findet man jeweils 2 Versionen von der Addier- Funktion. Bei der C Variante heißen die Funktionen genau gleich wie im Quellcode deklariert, wohingegen eine automatische Indexierung bei der C++ Variante erfolgt. In beiden Versionen werden jeweils 64 byte für die \textit{uint8\_t} und 72 byte für die \textit{int16\_t} Funktion alloziert. Es kann durchaus sein dass bei anderen Optimierungsstufen die Funktionen als inline kompiliert werden, jedoch entsteht auch dann nie ein Unterschied zwischen der C und C++ Version.


\begin{figure}[!htb]
	\begin{subfigure}[b]{0.5\textwidth}
		\begin{lstlisting}[gobble=6, title={Analyse C++}, language=bash, numbers=none]
		$ arm-none-eabi-g++ -c -O0 main.cpp
		$ arm-none-eabi-nm a.out --print-size
		...
		00000000 00000040 W _Z3addIhET_S0_S0_
		00000000 00000048 W _Z3addIsET_S0_S0_
		...
		\end{lstlisting}
	\end{subfigure}
	%
	\begin{subfigure}[b]{0.5\textwidth}
		\begin{lstlisting}[gobble=6, title={Analyse C}, language=bash, numbers=none]
		$ arm-none-eabi-gcc -c -O0 main.c
		$ arm-none-eabi-nm a.out --print-size
		...
		00000000 00000040 t a
		00000040 00000048 t b
		...
		\end{lstlisting}
	\end{subfigure}
\end{figure}

Zudem kann man erkennen das die Funktionen in der C Version mit \textbf{t} markiert sind und somit in die \textit{.text} Sektion gelinkt werden. Würde man in einer anderen C Datei genau die gleiche Funktionen implementieren würde man nach dem linken 2 Versionen von genau der gleichen Funktion in der auszuführenden Datei (Executable) finden. Hierbei sind die Funktionen a und b fest an die jeweilige Objektdatei gebunden. In der C++ Version sind beide Funktionen als WEAK deklariert und befinden sich in einer eigenen Link Sektion. Dies ermöglicht es dem Linker Optimierungen vorzunehmen falls es mehrere Implementierungen des gleichen Templates in verschieden Objekt Dateien gibt. Dieses Compiler Verhalten ist auch unter dem Namen \textbf{Borland Model} bekannt.

\begin{figure}[!htb]
	\begin{subfigure}[b]{0.5\textwidth}
		\begin{lstlisting}[gobble=6, title={Analyse C++}, language=bash, numbers=none]
		$ arm-none-eabi-objdump -d main.o

		-> .text:
		00000000 <main>:
		...
		
		-> .text._Z3addIhET_S0_S0_:
		00000000 <_Z3addIhET_S0_S0_>:
		...

		-> .text._Z3addIsET_S0_S0_:
		00000000 <_Z3addIsET_S0_S0_>:
		...
		
		\end{lstlisting}
	\end{subfigure}
	%
	\begin{subfigure}[b]{0.5\textwidth}
		\begin{lstlisting}[gobble=6, title={Analyse C}, language=bash, numbers=none]
		$ arm-none-eabi-objdump -d main.o
		
		-> .text:
		00000088 <main>:
		...
		
		
		00000000 <a>:
		...
		
		
		00000040 <b>:
		...
		\end{lstlisting}
	\end{subfigure}
\end{figure}

\subsubsection{Fazit}
Funktions- Templates erhöhen die Lesbarkeit des Quellcodes und bewirken das man Fehler nur in einer Funktion beheben muss und somit die Wartbarkeit erheblich erhöhen. Zudem kann sich die Verwendung von Templates positiv auf die Größe des Executables auswirken da der Linker Optimierungen vornehmen kann. Templates sollten auch wenn möglich in einer header Datei definiert werden und wenn nötig in der .cpp Datei eingebunden werden. Bei großen Projekten kann sich dies jedoch negativ auf die Übersetzungszeit auswirken da der Template Code mehrmals kompiliert werden muss.
\newpage

\subsection{Arrays}
In C++ gibt es mehrere Möglichkeiten Daten in Arrays zusammenzufassen. C- Array, \textit{sdt::vector} und \textit{std::array} sind die 3 bekanntesten Modelle um Daten zu speichern und werden in diesem Kapitel näher unter die Lupe genommen. Als embedded Programmierer sollte man genau wissen welche Methode für den jeweiligen Anwendungsfall die beste Wahl ist.

\subsubsection{C- Array / std::array}
Das klassische C- Array ist nach wie vor weit verbreitet und kann auch in C++ weiter verwendet werden. Jedoch sollte man in neuen Projekten darauf verzichten da es in der Standard C++ Bibliothek verschiedene Containerklassen gibt die übersichtlicher aufgebaut sind und somit gängige Fehler im Vorhinein eliminieren. Die \textit{std::array} Containerklasse is das Pendant zum C- Array, bietet jedoch einige Vorteile was Elementzugriff oder Informationen über die Kapazität das Arrays betrifft. Näher zu erwähnen ist die Methode \textbf{at} mit der man Zugriff auf einzelne Elemente des Arrays bekommt, jedoch gegenüber \textbf{[ ]} eine Grenzen Überprüfung während der Laufzeit stattfindet. Dies kann sehr nützlich sein da der Zugriff auf nicht existierende Elemente einer der häufigsten Fehler bei C- Arrays darstellt. \newline \newline Ein zusätzlicher Vorteil bieten die Standard C++ Containerklassen da diese Iteratoren zu Verfügung stellen womit man verschiedene Algorithmen der Standard Bibliothek verwenden kann. Somit kann man auf vorhandenen und getesteten Code zurückgreifen wenn es ums sortieren oder das manipulieren eines Arrays geht. \newline \newline Das nachfolgende Beispiel zeigt wie man mittels C- Array und \textit{std::array} ein \textbf{int} Array mit jeweils 10 Elementen mit 0 initialisiert und dann mit Daten befühlt.


\begin{figure}[!htb]
	\begin{subfigure}[b]{0.5\textwidth}
		\lstset{language=C++,caption={C- Array}}
		\lstinputlisting{../Code_Samples/std_vector_vs_std_array_vs_c_array/C_Array/c_array.cpp}
		\label{fig:7}
	\end{subfigure}
	%
	\begin{subfigure}[b]{0.5\textwidth}
		\lstset{language=C++,caption={std::array}}
		\lstinputlisting{../Code_Samples/std_vector_vs_std_array_vs_c_array/std_array/stdArray.cpp}
		\label{fig:8}
	\end{subfigure}
\end{figure}

\subsubsection{std::vector}
Bei der \textit{sdt::vector} Containerklasse hat man die Möglichkeit die Größe des Arrays dynamisch anzupassen. Somit ist \textit{sdt::vector} wesentlich komplexer und mit Vorsicht zu genießen da Speicher zur Laufzeit am Stack oder Heap alloziert werden muss. Dies ist auch dadurch zu erkennen dass sizeof(std::vector<int>) nicht wie bei \textit{std::array} oder dem C- Array die eigentliche Größe in Bytes zurückliefert sondern immer 12 welche lediglich zur Verwaltung von \textit{std::vector} benötigt werden und die eigentlichen Daten am Heap gespeichert werden. Bei embedded Projekten sollte man auf die \textit{sdt::vector} Klasse verzichten und wenn eine dynamische Speicherverwaltung von Nöten ist bieten gängige RTOS oder OS Systeme bessere Mechanismen an, die im Fehlerfall (Heap/Stack Überläufe) wesentlich besser zu Debuggen sind.

\subsubsection{Analyse}
Kompiliert man die C- Array und \textit{std::array} Variante jeweils mit der Optimierungsstufe \textbf{-0s} kann man keinen unterschied zwischen den beiden Implementierungen feststellen. Jedoch einsteht ein geringer Overheat bei Verwendung von \textit{std::array} in Kombination mit niedrigeren Optimierungsstufen die durch die höhere Abstraktion zum eigentlichen Speicher Segment zu erklären ist. Auch zu erkennen ist dass bei beiden Implementierungen jeweils Speicher für genau 10 \textbf{int} Werte statisch in der \textbf{bss} Sektion reserviert wird.


\begin{figure}[!htb]
	\begin{subfigure}[b]{0.5\textwidth}
		\begin{lstlisting}[gobble=6, title={C- Array}, language=bash, numbers=none]
		$ arm-none-eabi-size a.out
		text  data  bss  dec   hex
		1840  1092  64   2996  bb4
		
		$ arm-none-eabi-nm a.out --print-size
		...
		00018bb0 00000028 B a
		...
		\end{lstlisting}
	\end{subfigure}
	%
	\begin{subfigure}[b]{0.5\textwidth}
		\begin{lstlisting}[gobble=6, title={std::array}, language=bash, numbers=none]
		$ arm-none-eabi-size a.out
		text  data  bss  dec   hex
		1840  1092  64   2996  bb4
		
		$ arm-none-eabi-nm a.out --print-size
		...
		00018bb0 00000028 B a
		...
		\end{lstlisting}
	\end{subfigure}
\end{figure}

\subsubsection{Fazit}
Schlussfolgernd kann man Sagen dass \textit{std::array} ohne weiteres in embedded Projekten verwenden werden darf und eine Reihe von Vorteilen gegenüber dem C- Array bietet. Auch die Kompatibilität zu älterem Code der möglicherweise noch klassische Pointer benötigt sollte kein Problem darstellen da man mit der \textit{std::array} Methode \textbf{data} direkten Zugriff auf das darunterliegende Array bekommt. In der Standard C++ Bibliothek findet man auch noch einige andere Containerklassen wie \textit{std::list} oder \textit{std::deque} die sich zur Speicherung von Daten anbieten, jedoch auch wie \textit{std::vector} wesentlich komplexer sind und somit nur zum Einsatz kommen sollten wenn Speicherverbrauch und CPU Auslastung keine wesentliche Rolle spielen.
\newpage

\subsection{Zeichenketten}
Bei textbasierten Schnittellen oder Dateioperationen kommt man um Zeichenketten nicht herum. In C++ kann man die Klasse \textit{std::string} aus der C++ Standardbibliothek verwenden oder man benutzt weiterhin klassische C Strings. Der größte Vorteil von \textit{std::string} ist dass dieser Datentyp seine exakte Größe kennt und somit unerlaubte Zugriffe außerhalb des zugewiesenen Speicher vermieden werden können. Dies ist ein bekanntes Problem bei C Strings in Kombination mit Funktionen aus der Standardbibliothek \textit{string.h}, da man hier extrem aufpassen muss dass man nicht über die Grenzen hinaus operiert und Zeichenketten stets richtig mit '\textbackslash 0' terminiert. \newline\newline
Um die Funktionsweise von \textit{std::string} besser zu verstehen analysieren wir die Größe der Datentypen \textit{std::string} und \textit{char}. Das die Größe von \textit{char} 1 Byte ist sollte keine Überraschung sein, jedoch ist einem auf den ersten Blick unklar warum die Größe von \textit{std::string} 24 Byte ist.

\begin{table}[!htb]
	\centering
	\begin{tabular}{| l | c | r |}
		\hline
		\textbf{Datentyp}  & \textbf{Größe mittels sizeof()} \\ \hline
		std::string        & 24 \\ \hline
		char       		   & 1  \\ \hline
	\end{tabular}
	
	\caption{Größe von std::string und char}
	\label{tbl:size_string_char}
	% Verweis im Text mittels \ref{tbl:beispieltabelle}
	
\end{table}

Analysiert man die \textit{std::string} Klasse findet man heraus dass diese eine Instanziierung von der Template Klasse \textit{std::basic\_string} mit dem Datentypen \textit{char} ist. Schaut man sich die Header-Datei dieser Klasse an kann man ein Datenschema wie im Quellcode 19 vereinfacht dargestellt erkennen. Nun weiß man auch warum sizeof(std::string) 24 ergibt. Die Daten setzen sich aus einem Pointer \textit{*data} (4 byte) der auf den Datenblock zeigt, einer Variable \textit{string\_lenght} (4 byte) welche die Länge des Strings beinhaltet und einer Union (16 byte) welche als Buffer dient oder als Variable die Anzahl des allozierten Speichers am Heap beinhaltet.\newline


\begin{figure}[!htb]
	\centering
	\begin{subfigure}[b]{0.5\textwidth}
		\lstset{language=C++,caption={Datenschema std:string}, otherkeywords = {size_t}}
		\lstinputlisting{../Code_Samples/Zeichenketten/stdString/datenSchema_std_string.cpp}
		\label{lst:9}
	\end{subfigure}
\end{figure}

Solange die Zeichenkette weniger als 17 Zeichen beinhaltet, werden Daten im lokalen Datenblock von 16 Byte abgelegt auf welchen auch der Zeiger \textit{*data} zeigt. Überschreitet die Zeichenkette die Länge von 16 Zeichen wird zur Laufzeit dynamisch Speicher am Heap reserviert wo dann der neue String auch hin kopiert wird. Jetzt zeigt der Zeiger \textit{*data} nicht mehr auf den lokalen Buffer sondern auf den am Heap allozierten Speicher.
Die Variable \textit{allocated\_data} beinhaltet nun die Größe des allozierten Speichers am Heap. Um Speicher zu sparen wurde der Buffer \textit{local\_data[16]} und die Variable \textit{allocated\_data} in eine Union verpackt da immer nur eine zur gleichen Zeit verwendet wird. Die Größe des allozierten Speichers am Heap muss mindestens so groß sein wie die Länge der eigentlichen Zeichenkette (\textit{allocated\_data} >= \textit{string\_lenght}).\newline\newline
Das nachfolgende Beispiel verdeutlicht wie dynamisch Speicher am Heap alloziert wird wenn man die Länge von \textit{std::string} dynamisch verändert. Dazu wird die Zeichenkette bei jedem Schleifendurchgang um das Zeichen '=' erweitert. Die Funktionen \textit{malloc} und \textit{free} wurden so manipuliert das diese jeweils ein Text ausgeben wenn Speicher am Heap alloziert oder de-alloziert wird.

\begin{figure}[!htb]
	\begin{subfigure}[b]{0.5\textwidth}
		\lstset{language=C++,caption={Dynamisches Verhalten}}
		\lstinputlisting{../Code_Samples/Zeichenketten/stdString/std_heap_mem.cpp}
		\label{lst:10}
	\end{subfigure}
	%
	\begin{subfigure}[b]{0.5\textwidth}
	\begin{lstlisting}[gobble=6, title={Ausgabe Quellcode (20)}, language=bash, numbers=none]
	   02: =                                                                           
 	  03: ==                                                                          
	   :::                                                               
	   15: ==============                                                              
	   16: ===============                                                             
	   * Allocate 31 bytes                                                             
	   17: ================                                                            
	   18: =================                                                           
	   :::                                            
	   30: =============================                                               
	   31: ==============================                                              
	   * Allocate 61 bytes                                                             
	   * Deallocate                                                                    
	   32: ===============================                                               
	   33: ================================                                             	
	\end{lstlisting}
	\end{subfigure}
\end{figure}

Wie bei den C Strings ist auch bei \textit{std::string} jede Zeichenkette mit '\textbackslash 0' terminiert. Fügt man das 17 Zeichen hinzu werden 31 Bytes am Heap alloziert da der interne Buffer mit 16 bytes jetzt zu klein ist. Wächst die Zeichenkette auf 32 Zeichen an werden weiter 61 Bytes alloziert wohin die neue Zeichenkette kopiert wird. Nach dem Kopier- Vorgang wird der alte Speicher von 31 Bytes wieder freigegeben. Erkennbar ist also dass der Speicher jeweils um das doppelte wächst sollte der momentane Speicher am Heap nicht mehr ausreichend sein. Die meisten modernen Compiler verfolgen eine ähnliche Strategie was das Verhalten von \textit{std::string} angeht, jedoch kann man Unterschiede in der Größe des lokalen Buffers oder dem Algorithmus wie Speicher am Heap alloziert wird erkennen. \newpage

Die \textit{std::string} Klasse stellt eine Reihe vom Methoden zu Verfügung die das Arbeiten mit Strings sehr vereinfachen. Solche Methoden bieten eine ähnliche oder erweiterte Funktionalität wie die aus der Standard C Bibliothek \textit{string.h} und können in diversen Dokumentationen nachgeschlagen werden. Da in kleinen embedded Systemen die Speicherverwaltung eine wichtige Rolle spielt sollen die Methoden welche Auskünfte über Kapazität und Länge der Zeichenkette geben näher analysiert werden. Grundsätzlich muss man bei der \textit{std::string} Klasse zwischen 2 Größen unterscheiden: Der eigentlichen String Länge und des Speichers der momentan zu Verfügung steht. Tabelle \ref{tbl:string_method} unterteilt die Methoden in genau diese 2 Gruppen.

\begin{table}[!htb]
	\centering
	\begin{tabular}{| l | c | r |}
		\hline
		\textbf{String Länge}  & \textbf{Kapazität} \\ \hline
		size()        & capacity()				\\ \hline
		lenght()      & reserve() 	    		\\ \hline
		empty()       & shrink\_to\_fit() 		\\ \hline
		resize()      &   						\\ \hline
		clear()       &   					 	\\ \hline
		max\_size()   & 						\\ \hline
	
	\end{tabular}
	
	\caption{Überblick Methoden über Kapazität und Länge}
	\label{tbl:string_method}
	% Verweis im Text mittels \ref{tbl:beispieltabelle}
\end{table}
Lediglich die Methoden \textit{capacity()}, \textit{reserve()} und \textit{shrink\_to\_fit()} beziehen sich auf die Speicherverwaltung des Strings, bei allen anderen Funktionen geht es um die reine Länge der Zeichenkette. Da bei \textit{std::string} Zeichen als ASCII-byte interpretiert werden liefern die Methoden \textit{size()} und \textit{lenght()} genau das gleiche Ergebnis. Das nachfolgende Beispiel soll Unterschiede noch einmal hervorheben. \newline\newline
Analysiert man die Ausgabe vom Quellcode 22 hat der String eine Länge von 10 Zeichen und eine Kapazität von 15 Byte nach der Initialisierung. Ruft man die Methode \textit{reserve()} mit 500 auf, werden 500 Byte alloziert. Beim Aufruf der Methode \textit{rezize()} mit 5, wird lediglich die Zeichenkette auf eine Länge von 5 Zeichen reduziert. Die Methode \textit{clear()} löscht alle Zeichen ändert aber nichts am alloziertem Speicher. Das Ergebnis der Methode \textit{max\_size()} ist nicht sehr aussagekräftig da dies nur ein konstanter Wert ist und \textbf{keine} Informationen über den noch verfügbaren Speicher am Heap liefert. Die Methode \textit{shrink\_to\_fit()} die es ab C++11 gibt sollte den allozierten Speicher auf den kleinstmöglichen Wert begrenzen damit der eigentliche String noch hineinpasst. Dies funktioniert jedoch nur bedingt da die Methode nicht bindend ist und der Optimierungsgrad bei der Klasse selbst liegt.

\begin{figure}[!htb]
	\begin{subfigure}[b]{0.65\textwidth}
		\lstset{language=C++,caption={Kapazität von std::string}}
		\lstinputlisting{../Code_Samples/Zeichenketten/stdString/capacity.cpp}
		\label{lst:11}
	\end{subfigure}
	%
	\begin{subfigure}[b]{0.35\textwidth}
		\begin{lstlisting}[gobble=6, title={Ausgabe Quellcode (22)}, language=bash, numbers=none]
	   String: Hallo Welt                                                              
	   size() = 10                                                                     
	   length() = 10                                                                   
	   max_size() = 2147483647                                                         
	   capacity() = 15                                                                 
	                                                          
	   String: Hallo Welt                                                              
	   size() = 10                                                                     
	   length() = 10                                                                   
	   max_size() = 2147483647                                                         
	   capacity() = 500                                                                
	   
	   String: Hallo                                                                   
	   size() = 5                                                                      
	   length() = 5                                                                    
	   max_size() = 2147483647                                                         
	   capacity() = 500                                                                
	                                                                    
	   String: Hallo                                                                   
	   size() = 5                                                                      
	   length() = 5                                                                    
	   max_size() = 2147483647                                                         
	   capacity() = 50                                                                 
	   
	   String:                                                                         
	   size() = 0                                                                      
	   length() = 0                                                                    
	   max_size() = 2147483647                                                         
	   capacity() = 50
	   
	   
	   String_is_empty            
                               
                               
                                          	
		\end{lstlisting}
	\end{subfigure}
\end{figure}

\newpage
Da wir jetzt einen relativ guten Eindruck über den Unterschied der Speicherverwaltung am RAM (Daten, Heap) von \textit{std::string} gegenüber von C-Strings haben widmen wir uns jetzt dem ROM (Code) Speicherbedarf. Dieser wird hauptsächlich durch die Funktionen beeinflusst welche in der C und C++ Standardbibliothek definiert sind. Um den ROM Overhead von \textit{std::string} herauszufinden wurde ein lauffähiges Programm was Strings manipuliert jeweils einmal mit Hilfe von C- Strings und \textit{std:.string} implementiert. Das nachfolgende Beispiel zeigt auch dass man bei \textit{std::string} Operatoren wie + und << sinnvoll verwenden kann um zum Beispiel Strings aneinanderzuhängen.
\newpage

 Um keine Fehler in der Analyse zu begehen wurde das nachfolgende Beispiel compiliert und gelinkt damit es auf einem reellen Mikrocontroller lauffähig ist. Zur Analyse wurden nun die Größen der verschiedenen Link Sektionen von allen gelinkten Objekten der C und C++ Standardbibliothek und von der main.o Datei aufgelistet.

\begin{figure}[!htb]
	\begin{subfigure}[b]{0.5\textwidth}
		\lstset{language=C++,caption={std::string}}
		\lstinputlisting{../Code_Samples/Zeichenketten/stdString/main.cpp}
		\label{fig:11}
	\end{subfigure}
	%
	\begin{subfigure}[b]{0.5\textwidth}
		\lstset{language=C++,caption={C- String}}
		\lstinputlisting{../Code_Samples/Zeichenketten/C_Char/main.cpp}
		\label{fig:12}
	\end{subfigure}
\end{figure}

Da wir hier ein komplett lauffähiges Projekt mit OS analysieren ist die Größe der einzelnen Sektionen nicht sehr aussagekräftig sondern die Differenz zwischen beiden Implementationen von größerer Bedeutung. Erkennbar ist dass die Link Größen von der C Bibliothek und der main.o relativ ähnlich ausschauen. Jedoch fügt die C++ Bibliothek mit rund 8,5 KByte einen relativ großen Overhead an ROM (Code) dazu. Dieser doch recht hoher Overhead ist dadurch zu erklären dass die C++ Bibliothek hier zum ersten mal ins Projekt eingebunden wurde und somit nicht alles auf \textit{std::string} zurückzuführen ist. Der Overhead ist daher zum größten Teil einmalig da die Initialisierungs- Routinen der C++ Bibliothek doch einen recht großen Anteil an dem Overhead haben dürften. Wie groß jetzt der Overhead von \textit{std::string} wirklich ist kann man nicht so generell sagen, da es extrem von den Compiler Einstellungen (Flags) und der verwendeten C++ Bibliothek abhängt. Bei Verwendung einer auf ROM optimierten C++ Bibliothek wie zum Beispiel der UlibC++, die speziell für embedded Projekte entwickelt wurde, kann man durchaus noch etwas Speicher sparen.


\begin{figure}[!htb]
	\begin{subfigure}[b]{0.5\textwidth}
		\begin{lstlisting}[gobble=6, title={std::string}, language=bash, numbers=none]
		Module 			.text		.data		.bss
		[lib]\c.a		25452		2472		11
		[lib]\c++.a		8558		20			204
		main.o			372		0			132
		
		\end{lstlisting}
	\end{subfigure}
	%
	\begin{subfigure}[b]{0.5\textwidth}
		\begin{lstlisting}[gobble=6, title={C- Strings}, language=bash, numbers=none]
		Module 			.text		.data		.bss
		[lib]\c.a		24319		2472		89
		[lib]\c++.a		4			0			0
		main.o			355		0			132
		
		\end{lstlisting}
	\end{subfigure}
\end{figure}
\newpage
\subsubsection{Fazit}
Ob man nun \textit{std::string} in seinem Projekt verwenden soll, hängt eher von der generellen Frage ab ob man Funktionen aus der Standard C++ Bibliothek verwenden will. Kann man mit dem doch relativ hohen Overhead leben bietet \textit{std::string} doch einige Vorteile gegenüber klassischen C- Strings. Jedoch geht eher Gefahr mit der dynamischen Speicher Verwaltung von \textit{std::string} daheer, da diese doch relativ komplex sein kann und durchaus zu bösen Fehlern am Heap oder Stack führen kann.


\newpage
\subsection{Zeiger vs Referenzen}
Wenn große Datenblöcke einer Funktion übergeben werden sollen, übergibt man meist nicht den kompletten Datenblock sondern eine Referenz oder einen Zeiger auf diesen. In C++ kann man dazu Referenzen benutzen welche meist eine bessere Alternative zu den Zeigern darstellen. Zeiger sind Variablen die auf eine Adresse im Speicher zeigen, welche Daten oder Programmcode beinhalten können. Mit Referenzen kann man dies auch, jedoch können diese während der gesamten Laufzeit immer nur auf ein Datenobjekt referenzieren und können daheer auch als eine Art Alias für ein anderes Objekt angesehen werden. Im gegensatz zu Referenzen können Zeiger ihren Wert verändern und somit während der Laufzeit auf beliebig viele Datenblöcke zeigen. Bei Zeigern besteht somit immer die Möglichkeit dass dieser nicht auf einen gültigen Speicherblock zeigt und sollte daheer immer auf dessen Gültigkeit überprüft werden. \newline \newline
Wenn es ums manipulieren von Datenblöcken geht, sieht man sehr oft noch die Verwendung von Zeigern da man hier in einer Schleife alle Elemente eines Datenblock durch iterieren kann indem man den Zeiger bei jedem Durchlauf erhöht. Das nachfolgende Beispiel zeigt wie man die Verwendung von Zeigern vermeiden kann indem man seinen Code etwas moderner gestaltet. Das Beispiel- Programm soll die Daten von jeweils 100 Personen ausgeben.\newline

\begin{figure}[!htb]
	\begin{subfigure}[b]{0.5\textwidth}
		\lstset{language=C++,caption={Zeiger Beispiel}}
		\lstinputlisting{../Code_Samples/Pointer_vs_reference/Pointer/main.cpp}
		\label{fig:13}
	\end{subfigure}
	%
	\begin{subfigure}[b]{0.5\textwidth}
		\lstset{language=C++,caption={Referenz Beispiel}}
		\lstinputlisting{../Code_Samples/Pointer_vs_reference/Reference/main.cpp}
		\label{fig:14}
	\end{subfigure}
\end{figure}

Bei dem Zeiger- Beispiel wird zuerst ein neuer Datentyp \textit{Person} mittels \textit{typedef struct} angelegt welche die Daten einer Person beschreibt. In der main Funktion wird dann ein Array vom Type \textit{Person} mit der Größe 100 angelegt. Die Funktion welche die Informationen aller Personen ausgibt benötigt dann einen Zeiger auf das Array und die zusätzliche Information wie viele Elemente vom Type \textit{Person} ausgegeben werden sollen.\newline \newline
Bei dem Beispiel mit Referenzen wird zuerst eine einfache Struktur \textit{data} mittels \textit{struct} angelegt und dann ein neuer Datentyp mithilfe der Containerklasse \textit{std::array} angelegt. Die Größe von 100 ist ein fixer Bestandteil dieses Datentyps womit man sich die Anzahl der auszugeben Elemente als Funktionsparameter sparen kann. Zudem kann man mit der \textit{for-each} Schleife die es seit C++11 gibt eleganter und sicherer durch alle Elemente durch iterieren. 

\subsubsection{Analyse}
Die Analyse zeigt dass Referenzen keinesfalls einen Overhead an Speicher mit sich bringen. Das Beispiel mit Zeigern ist sogar um 9 Byte Größer was durch den zusätzlichen Parameter in der \textit{print\_info} Funktion zu erklären ist. Ersetzt man beim Zeiger Beispiel die Länge durch einen Konstanten Wert erzeugt der Compiler bei beiden Versionen genau das Gleiche Ergebnis.

\begin{figure}[!htb]
	\begin{subfigure}[b]{0.5\textwidth}
		\begin{lstlisting}[gobble=6, title={Analyse Zeiger Beispiel}, language=bash, numbers=none]
		$ arm-none-eabi-g++ -c -Os main.cpp
		$ arm-none-eabi-size main
		...
		text    data     bss
		163        0       0
		...
		\end{lstlisting}
	\end{subfigure}
	%
	\begin{subfigure}[b]{0.5\textwidth}
		\begin{lstlisting}[gobble=6, title={Analyse Referenze Beispiel}, language=bash, numbers=none]
		$ arm-none-eabi-g++ -c -Os main.c
		$ arm-none-eabi-size main.o
		...
		text    data     bss
		155        0       0
		...
		\end{lstlisting}
	\end{subfigure}
\end{figure}

\subsubsection{Fazit}
Als Fazit kann man sagen dass man Referenzen gegenüber Zeigern wenn möglich bevorzugen soll und seinen Code so gestalten soll das die Verwendung von Zeigern überflüssig wird. Referenzen haben den Vorteil dass die Syntax mit dem Punkt Operator übersichtlicher wirkt, eine Referenz immer auf ein gültiges Datenobjekt zeigt und somit sicherer ist und gewisse Vorteile zeigen wenn es um kopier- Konstruktoren oder das Überladen von Operatoren geht.
\newpage
\subsection{Namensräume}
Namensräume (Namespaces) sind vor allem dann nützlich wenn es um die modulare Programmierung geht. Hiermit können Namens Konflikte im Vorhinein eliminiert werden. Jeder war schon einmal in der Situation dass der Compiler einen Fehler produziert hat weil eine Funktion oder Variable schon einmal in einer anderen Datei deklariert wurde. Dies tritt vor allem bei größeren Projekten oder bei der Verwendung von externen Bibliotheken auf. In C++ kann man einzelnen Module in Namensräume verpacken um somit eine bessere Trennung von verschieden Code Teilen zu erlangen. Der Namensraum \textit{sdt} in dem sich die Standard C++ Module befinden dürfte jedem ein Begriff sein. Das nachfolgende Beispiel zeigt wie man Namensräume richtig verwenden kann um eine sinnvolle Modularisierung zu erreichen. \newline

\begin{figure}[!htb]
	\begin{subfigure}[b]{0.5\textwidth}
		\lstset{language=C++,caption={serial.cpp}}
		\lstinputlisting{../Code_Samples/Namespaces/Example/serial.cpp}
		\label{fig:15}
	\end{subfigure}
	%
	\begin{subfigure}[b]{0.5\textwidth}
		\lstset{language=C++,caption={serial.h}}
		\lstinputlisting{../Code_Samples/Namespaces/Example/serial.h}
		\label{fig:16}
	\end{subfigure}
\end{figure}
\newpage
Das Beispiel soll demonstrieren wie man einen Treiber für eine Serielle Schnittelle mithilfe von Namensräumen implementieren könnte. Zuerst haben wir den Namensraum \textit{driver} deklariert der alle Hardware Treiber eines Mikrocontrollers beinhalten soll. In der Datei \textit{serial.h} befinden sich die Funktionsprototypen welche als Schnittelle für dieses Modul dienen. Diese müssen natürlich in den Namensraum \textit{driver} verpackt werden. In der Datei \textit{serial.cpp} werden nun die Funktionen \textit{serial\_init} und \textit{serial\_send} im Namensraum \textit{driver} implementiert.\newline \newline Erkennbar ist dass sich in der Datei \textit{serial.cpp} noch eine anonymer Namensraum befindet. Anonyme Namensräume sind an dem fehlenden Namen erkennbar und dienen dazu Variablen, Funktionen oder Typen zu deklarieren welche nur innerhalb dieses Moduls (.cpp Datei) sichtbar sein sollen. Die Funktion send\_byte() und die Variable \textit{is\_init} vom Type \textit{state} sind somit nur in der Datei \textit{serial.cpp} gültig. Dieses Verhalten kann man natürlich auch mit dem Schlüsselwort \textit{static} erzeugen, jedoch mit dem Nachteil dass Typdeklarationen nicht nach außen verborgen werden. Der neue Type \textit{state} der den Status des Moduls beschreibt macht natürlich nur Sinn in dieser .cpp Datei und sollte daheer nicht nach außen sichtbar sein. Das Nachfolgende Beispiel zeigt 2 Methoden wie man das zuvor erstellte Modul verwenden kann.

\begin{figure}[!htb]
	\begin{subfigure}[b]{0.5\textwidth}
		\lstset{language=C++,caption={using keyworld}}
		\lstinputlisting{../Code_Samples/Namespaces/Example/main_1.cpp}
		\label{fig:17}
	\end{subfigure}
	%
	\begin{subfigure}[b]{0.5\textwidth}
		\lstset{language=C++,caption={:: Scope Operator}}
		\lstinputlisting{../Code_Samples/Namespaces/Example/main_2.cpp}
		\label{fig:18}
	\end{subfigure}
\end{figure}
Mit dem Schlüsselwort \textit{using} kann man dem Compiler mitteilen dass man nun die Funktionen welche sich im Namensraum \textit{driver} befinden verwenden möchte. Möchte man jedoch nicht den ganzen Namensraum einbinden kann man mit dem Scope Operator :: auf Funktionen oder Variablen aus dem jeweiligen Namensraum zugreifen.


\subsubsection{Fazit}
Namensräume sind ideal wenn es um die Modularisierung von Projekten geht und bieten sich perfekt an um Betriebssystem Funktionalitäten vom User Space zu trennen. Auch anonyme Namensräume sollten verwendet werden um Funktionalität nach außen hin zu verbergen. Ein Speicher Overhead kann auch nicht einstehen da Namensräume lediglich dazu dienen dem Compiler mitzuteilen welche Funktionen er zu verwenden hat.
\newpage

\subsection{Klassen}
In diesem Kapitel werden die Klassen analysiert welche die Grundlage für das OOP Konzept in C++ darstellen. Dazu wird eine Beispiel Klasse implementiert die eine Serielle Schnittelle eines Mikrocontrollers beschreiben soll. Diese Klasse wird dann fortlaufend während des Kapitels erweitert und adaptiert um zu analysieren wie sich Klassen und dessen Konzepte in Bezug auf Performance und Speicher verhalten. Des weiteren werden in diesem Kapitel einige Richtlinien aufgestellt wie man Klassen sinnvoll in embedded Projekten einsetzen kann. 
\subsubsection{Erstes Beispiel}
Die erste Definition unserer Klasse \textit{Serial} beinhaltet 2 private Variablen \textit{(baudrate, mode)} und 2 öffentliche Methoden \textit{(set\_baudrate, set\_mode)}. Wie im Beispiel ersichtlich sollte man Membervariablen wenn Möglich immer im \textit{private} Block definieren und den Zugriff nur über Methoden (Getters / Setters) erlauben. Dies hat den Vorteil dass man die Variablen nur über die öffentlichen Schnittellen \textit{(set\_baudrate, set\_mode)} verändern kann und somit auch den Wertebereich überprüfen kann. Das direkte verbergen von Daten führt zu einer Datenkapselung womit man die Klasse als einzelnes Modul besser testen kann und man die Gewissheit hat dass die Variablen sich im gewünschtem Wertebereich befinden. Die Klassendefinition und die Implementierung der Klasse sollte man auch immer in separate Dateien verpacken was zu einer besseren Übersichtlichkeit führt. \newline 
\begin{figure}[!htb]
	\begin{subfigure}[b]{0.5\textwidth}
		\lstset{language=C++,caption={Klassen Implementierung}}
		\lstinputlisting{../Code_Samples/Klassen/Beispiel/serial.cpp}
		\label{fig:19}
	\end{subfigure}
	%
	\begin{subfigure}[b]{0.5\textwidth}
		\lstset{language=C++,caption={Klassendefinition}}
		\lstinputlisting{../Code_Samples/Klassen/Beispiel/serial.h}
		\label{fig:20}
	\end{subfigure}
\end{figure}

Analysiert man mit \textit{sizeof(Serial)} die Größe unserer Klasse erhält man das Ergebnis 8 Byte. Diese 8 Byte setzen sich aus den 2 \textit{int} Werten zusammen welche jeweils 4 Byte allozieren. Somit benötigt eine Klasse keinen zusätzlichen Speicher neben den eigentlichen Klassen Variablen.
% Beispiel (Wird verwendet für das ganze Kapitel)
% Class vs Struct
% Klassen Definition
% Public vs Private
% Datenkapselung (Getter & setter)
% Initialisierung von objeckten

% Klassenelemente
	% static & const
	% Rohe Zeiger als Klassenelemente
	% Virtuelle methoden

\subsubsection{Konstruktoren}

% C+11 Initilisierung von Variablen
\subsubsection{Destruktoren}
\subsubsection{Methoden}

% Inline Methoden

% Const Methoden
\subsection{Operatoren Überladen}
\subsection{Dynamische Speicher Objekte}
\subsection{Fehlerbehandlung}
\subsection{Eingabe- und Ausgabestreams}



%
% Hier beginnen die Verzeichnisse.
%
\clearpage
\ifthenelse{\equal{\FHTWCitationType}{HARVARD}}{}{\bibliographystyle{gerabbrv}}
\bibliography{Literatur}
\clearpage

% Das Abbildungsverzeichnis
\listoffigures
\clearpage

% Das Tabellenverzeichnis
\listoftables
\clearpage

% Das Quellcodeverzeichnis
\listofcode
\clearpage

\phantomsection
\addcontentsline{toc}{chapter}{\listacroname}
\chapter*{\listacroname}
\begin{acronym}[XXXXX]
    \acro{ABC}[ABC]{Alphabet}
    \acro{WWW}[WWW]{world wide web}
    \acro{ROFL}[ROFL]{Rolling on floor laughing}
\end{acronym}

%
% Hier beginnt der Anhang.
%
\clearpage
\appendix
\chapter{Anhang A}
\clearpage
\chapter{Anhang B}
\end{document}